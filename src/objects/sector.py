import datetime
from collections import OrderedDict

import src.misc.common as common
from src.misc.coords import EBCoords

type Int8 = int
type Int16 = int

USERDATA_TYPES = (Int8, Int16)

class Sector:
    """Instance of a sector on the map."""
    
    # Key: name, Value: datatype
    SECTORS_USERDATA = OrderedDict()
    
    def __init__(self, id: int, item: int, music: int, palette: int, palettegroup: int, tileset: int, setting: str, teleport: str,
                 townmap: str, townmaparrow: str, townmapimage: str, townmapx: int, townmapy: int):
        self.id = id
        self.item = item
        self.music = music
        self.palette = palette
        self.palettegroup = palettegroup
        self.tileset = tileset
        self.setting = setting
        self.teleport = teleport
        self.townmap = townmap
        self.townmaparrow = townmaparrow
        self.townmapimage = townmapimage
        self.townmapx = townmapx
        self.townmapy = townmapy
        
        # Key: name (as defined in SECTORS_USERDATA), Value: data
        self.userdata = {}

        self.coords = EBCoords.fromSector(int(id%32), int(id/32)) # (x, y) of sector location (in sector array)
        
    
    def attributesToDataDict(self) -> dict:
        return {
            "item": self.item,
            "music": self.music,
            "palette": self.palette,
            "palettegroup": self.palettegroup,
            "tileset": self.tileset,
            "setting": self.setting,
            "teleport": self.teleport,
            "townmap": self.townmap,
            "townmaparrow": self.townmaparrow,
            "townmapimage": self.townmapimage,
            "townmapx": self.townmapx,
            "townmapy": self.townmapy
        }
    
    def paletteToDataDict(self) -> dict:
        return {
            "palette": self.palette,
            "palettegroup": self.palettegroup,
            "tileset": self.tileset
        }
        
    def serialiseUserData(self) -> bytes:
        serialised: list[bytes] = []
        structData = Sector.getUserDataStructLayout()
        for k, v in structData.items():
            serialised.append(self.userdata.get(k, 0).to_bytes(v[0], "little"))
        return bytes().join(serialised)

    @classmethod
    def serialiseStructLayoutToCCS(cls) -> str:
        serialised = f"""\
// File autogenerated by EBME v{common.VERSION} at {datetime.datetime.now(datetime.timezone.utc).strftime("%Y-%m-%d %H:%M:%S (UTC)")}.
// Please do not edit manually - EBME can reimport this file for later edits.
// Import this file to use the below sector userdata struct offsets.
// `incbin` the associated binary file somewhere to add the data itself.

"""
        structData = cls.getUserDataStructLayout()
        offset = 0
        for k, v in structData.items():
            serialised += f"define SECTORUSERDATA_{k} = {offset} // Type: {v[1]}\n"
            offset += v[0]
        
        serialised += f"define SECTORUSERDATA_SIZEOF = {offset}"
        return serialised
    
    @classmethod
    def getUserDataStructLayout(cls) -> OrderedDict[str, int]:
        structLayout: OrderedDict[str, tuple[int, str]] = {}
        for k, v in cls.SECTORS_USERDATA.items():
            match v:
                # i love python
                case a if a is Int8:
                    structLayout[k] = (1, str(Int8))
                case b if b is Int16:
                    structLayout[k] = (2, str(Int16))
        return structLayout